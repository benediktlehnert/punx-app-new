{"ast":null,"code":"var _jsxFileName = \"/Users/benediktlehnert/Documents/GitHub/punx-app-new/src/screens/GameScreen.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useCallback } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { useGame } from '../context/GameContext';\nimport PunctuationCharacter from '../components/PunctuationCharacter';\nimport { shuffleArray } from '../utils/shuffle';\nimport { Button } from '../components/Button';\nimport '../styles/GameScreen.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst samplePhrases = {\n  period: [{\n    text: \"I love to play in the park\",\n    answer: \"period\",\n    position: 'end'\n  }, {\n    text: \"The sun is shining today\",\n    answer: \"period\",\n    position: 'end'\n  }],\n  exclamation: [{\n    text: \"What a wonderful day\",\n    answer: \"exclamation\",\n    position: 'end'\n  }, {\n    text: \"I can’t believe it\",\n    answer: \"exclamation\",\n    position: 'end'\n  }],\n  question: [{\n    text: \"How are you today\",\n    answer: \"question\",\n    position: 'end'\n  }, {\n    text: \"Where did you go\",\n    answer: \"question\",\n    position: 'end'\n  }],\n  comma: [{\n    text: \"After the movie we went home\",\n    answer: \"comma\",\n    position: 2\n  },\n  // After index 2 (after \"movie\")\n  {\n    text: \"Yes I would love to\",\n    answer: \"comma\",\n    position: 0\n  } // After index 1 (after \"Yes\")\n  ]\n};\nconst punctuationTypes = ['period', 'exclamation', 'question', 'comma'];\nconst GameOverDialog = ({\n  open,\n  onClose,\n  score\n}) => /*#__PURE__*/_jsxDEV(\"dialog\", {\n  open: open,\n  className: \"game-over-dialog\",\n  children: /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"dialog-content\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Time's Up!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 59,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      className: \"score-correct\",\n      children: [\"Correct Answers: \", score.correct]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 60,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      className: \"score-incorrect\",\n      children: [\"Incorrect Answers: \", score.incorrect]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 61,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      className: \"feedback\",\n      children: score.correct > score.incorrect ? \"Great job! You're getting really good at this!\" : \"Keep practicing, you're getting better!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 62,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"dialog-actions\",\n      children: /*#__PURE__*/_jsxDEV(Button, {\n        onClick: onClose,\n        children: \"Play Again\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 68,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 67,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 58,\n    columnNumber: 5\n  }, this)\n}, void 0, false, {\n  fileName: _jsxFileName,\n  lineNumber: 57,\n  columnNumber: 3\n}, this);\n_c = GameOverDialog;\nconst GameScreen = () => {\n  _s();\n  const navigate = useNavigate();\n  const {\n    punctuationType,\n    settings\n  } = useGame();\n  const [currentPhraseIndex, setCurrentPhraseIndex] = React.useState(0);\n  const [currentPhrase, setCurrentPhrase] = React.useState(null);\n  const [selectedMark, setSelectedMark] = React.useState(null);\n  const [isCorrect, setIsCorrect] = React.useState(null);\n  const [score, setScore] = React.useState({\n    correct: 0,\n    incorrect: 0\n  });\n  const [hasStarted, setHasStarted] = React.useState(false);\n  const [timeLeft, setTimeLeft] = React.useState(null);\n  const [gameOverOpen, setGameOverOpen] = React.useState(false);\n  const [shuffledTypes, setShuffledTypes] = React.useState(['period', 'exclamation', 'question', 'comma']);\n  const [feedback, setFeedback] = React.useState(null);\n  const timerRef = React.useRef(null);\n  const [dragPosition, setDragPosition] = useState(null);\n  const [closestDropZone, setClosestDropZone] = useState(null);\n  const [hoveredIndex, setHoveredIndex] = useState(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const [showingFeedback, setShowingFeedback] = useState(false);\n  const [lineBreaks, setLineBreaks] = useState([]);\n  const [activeDropZoneIndex, setActiveDropZoneIndex] = useState(null);\n  const [droppedIndex, setDroppedIndex] = useState(null);\n  const [feedbackTimeout, setFeedbackTimeout] = useState(null);\n  const [phraseLayout, setPhraseLayout] = useState({\n    lineBreaks: [],\n    dropZoneSpaces: []\n  });\n  const [droppedType, setDroppedType] = useState(null);\n  const phrases = React.useMemo(() => shuffleArray(Object.values(samplePhrases).flat()), []);\n  React.useEffect(() => {\n    setCurrentPhrase(phrases[currentPhraseIndex]);\n  }, [currentPhraseIndex, phrases]);\n  const startTimer = React.useCallback(() => {\n    if (!hasStarted && settings.timer) {\n      setHasStarted(true);\n      setTimeLeft(settings.timeLimit);\n    }\n  }, [hasStarted, settings.timer, settings.timeLimit]);\n  React.useEffect(() => {\n    if (hasStarted && settings.timer && timeLeft !== null && timeLeft > 0) {\n      timerRef.current = setInterval(() => {\n        setTimeLeft(prev => {\n          if (prev === null || prev <= 1) {\n            if (timerRef.current) {\n              clearInterval(timerRef.current);\n            }\n            setGameOverOpen(true);\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      return () => {\n        if (timerRef.current) {\n          clearInterval(timerRef.current);\n        }\n      };\n    }\n  }, [hasStarted, settings.timer, timeLeft]);\n  React.useEffect(() => {\n    return () => {\n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n      }\n    };\n  }, []);\n  const handleFirstInteraction = () => {\n    startTimer();\n  };\n  const getFeedbackMessage = (type, isCorrect) => {\n    if (isCorrect) {\n      return {\n        text: \"Great job! That's exactly right!\",\n        type: 'success'\n      };\n    }\n    const correctType = currentPhrase === null || currentPhrase === void 0 ? void 0 : currentPhrase.answer;\n    switch (correctType) {\n      case 'period':\n        return {\n          text: \"This sentence needs a period to show it's complete.\",\n          type: 'error'\n        };\n      case 'question':\n        return {\n          text: \"This is a question, so it needs a question mark.\",\n          type: 'error'\n        };\n      case 'exclamation':\n        return {\n          text: \"This sentence shows strong feeling or emotion, so it needs an exclamation mark!\",\n          type: 'error'\n        };\n      case 'comma':\n        return {\n          text: \"A comma is needed here to separate parts of the sentence.\",\n          type: 'error'\n        };\n      default:\n        return {\n          text: \"That's not quite right. Try again!\",\n          type: 'error'\n        };\n    }\n  };\n  const handleCharacterSelect = type => {\n    if (!currentPhrase) return;\n\n    // Start timer on first interaction if not started\n    if (!hasStarted) {\n      startTimer();\n    }\n    setSelectedMark(type);\n    const isCorrectMark = type === currentPhrase.answer;\n    setIsCorrect(isCorrectMark);\n    if (isCorrectMark) {\n      setScore(prev => ({\n        ...prev,\n        correct: prev.correct + 1\n      }));\n    } else {\n      setScore(prev => ({\n        ...prev,\n        incorrect: prev.incorrect + 1\n      }));\n    }\n\n    // Wait for animation then move to next phrase\n    setTimeout(() => {\n      setSelectedMark(null);\n      setIsCorrect(null);\n      goToNextPhrase();\n    }, 1000);\n  };\n  const goToNextPhrase = () => {\n    const nextIndex = (currentPhraseIndex + 1) % phrases.length;\n    setCurrentPhraseIndex(nextIndex);\n  };\n  const handleDrop = e => {\n    e.preventDefault();\n    e.currentTarget.classList.remove('dragover');\n    const droppedType = e.dataTransfer.getData('application/punctuation');\n    console.log('Dropped type:', droppedType); // Add this for debugging\n\n    if (droppedType) {\n      handleCharacterSelect(droppedType);\n    }\n  };\n  const handleDragOver = e => {\n    e.preventDefault(); // This is crucial for enabling drop\n    e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';\n  };\n  const handleDragLeave = e => {\n    e.preventDefault();\n    e.currentTarget.style.backgroundColor = 'transparent';\n  };\n  const handleDragStart = e => {\n    startTimer();\n    e.dataTransfer.setData('text/plain', e.currentTarget.id);\n  };\n  const findClosestWord = useCallback(dragPos => {\n    if (!dragPos) return null;\n\n    // Get all word elements\n    const wordElements = document.querySelectorAll('[data-dropzone=\"true\"]');\n    let closestDropZone = null;\n    let closestDistance = Infinity;\n    wordElements.forEach((element, index) => {\n      const rect = element.getBoundingClientRect();\n      const dropZoneCenter = {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2\n      };\n      const distance = Math.sqrt(Math.pow(dragPos.x - dropZoneCenter.x, 2) + Math.pow(dragPos.y - dropZoneCenter.y, 2));\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestDropZone = index;\n      }\n    });\n\n    // Only return the closest drop zone if it's within a reasonable distance (e.g., 200px)\n    return closestDistance < 200 ? closestDropZone : null;\n  }, []);\n  const getClosestWordIndex = (dragPos, words) => {\n    if (!dragPos) return null;\n\n    // Get the phrase container bounds\n    const container = document.querySelector('.phrase-container');\n    if (!container) return null;\n    const containerRect = container.getBoundingClientRect();\n\n    // Check if we're near the end of the phrase\n    const lastWord = words[words.length - 1];\n    const lastWordRect = lastWord.getBoundingClientRect();\n    const distanceToEnd = Math.abs(dragPos.x - (lastWordRect.right + 78));\n\n    // If we're near the end of the last line and it's an end position phrase\n    if ((currentPhrase === null || currentPhrase === void 0 ? void 0 : currentPhrase.position) === 'end' && dragPos.y > lastWordRect.top - 50 && dragPos.y < lastWordRect.bottom + 50 && dragPos.x > lastWordRect.right) {\n      return words.length - 1;\n    }\n\n    // Check each word position\n    for (let i = 0; i < words.length; i++) {\n      const word = words[i];\n      const rect = word.getBoundingClientRect();\n      const nextWord = words[i + 1];\n      const nextRect = nextWord === null || nextWord === void 0 ? void 0 : nextWord.getBoundingClientRect();\n\n      // If this is the last word, check if we're after it\n      if (!nextWord && dragPos.x > rect.right) {\n        return i;\n      }\n\n      // Check if we're between this word and the next\n      if (nextRect) {\n        const gap = {\n          left: rect.right,\n          right: nextRect.left,\n          top: Math.min(rect.top, nextRect.top),\n          bottom: Math.max(rect.bottom, nextRect.bottom)\n        };\n\n        // Check if we're in the gap between words\n        if (dragPos.x >= gap.left && dragPos.x <= gap.right && dragPos.y >= gap.top - 50 && dragPos.y <= gap.bottom + 50) {\n          return i;\n        }\n      }\n    }\n    return null;\n  };\n  const renderPhrase = () => {\n    if (!currentPhrase) return null;\n    const words = currentPhrase.text.split(' ');\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"phrase-container\",\n      style: {\n        width: '100%',\n        textAlign: 'center',\n        willChange: 'transform',\n        transform: 'translateZ(0)',\n        backfaceVisibility: 'hidden'\n      },\n      onDragEnter: () => setIsDragging(true),\n      onDragLeave: e => {\n        if (e.currentTarget === e.target) {\n          setIsDragging(false);\n          setDragPosition(null);\n          setActiveDropZoneIndex(null);\n        }\n      },\n      onDragOver: e => {\n        e.preventDefault();\n        const newPos = {\n          x: e.clientX,\n          y: e.clientY\n        };\n\n        // Update position immediately with minimal threshold\n        if (!dragPosition || Math.abs(newPos.x - dragPosition.x) > 2 ||\n        // Minimal threshold\n        Math.abs(newPos.y - dragPosition.y) > 2) {\n          setDragPosition(newPos);\n          const wordElements = document.querySelectorAll('[data-word-index]');\n          const newClosestIndex = getClosestWordIndex(newPos, wordElements);\n          if (newClosestIndex !== activeDropZoneIndex) {\n            setActiveDropZoneIndex(newClosestIndex);\n          }\n        }\n      },\n      onDrop: () => {\n        setIsDragging(false);\n        setDragPosition(null);\n      },\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          fontFamily: '\"Bookman Old Style Regular\", \"Bookman\", \"URW Bookman L\", serif',\n          fontWeight: 'normal',\n          fontSize: window.innerWidth < 600 ? '80px' : window.innerWidth < 960 ? '100px' : window.innerWidth < 1280 ? '120px' : '140px',\n          lineHeight: '1.1',\n          display: 'inline-block',\n          textAlign: 'left',\n          maxWidth: '90%',\n          margin: '0 auto',\n          WebkitFontSmoothing: 'antialiased',\n          WebkitTextSizeAdjust: '100%',\n          color: '#000000'\n        },\n        children: words.map((word, index) => {\n          const needsLineBreak = phraseLayout.lineBreaks.includes(index);\n          const needsDropZoneSpace = phraseLayout.dropZoneSpaces.includes(index);\n          const isDropZoneActive = isDragging && activeDropZoneIndex === index || droppedIndex === index;\n          return /*#__PURE__*/_jsxDEV(React.Fragment, {\n            children: [needsLineBreak && /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 408,\n              columnNumber: 36\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              \"data-word-index\": index,\n              style: {\n                display: 'inline-block',\n                fontFamily: '\"Bookman Old Style Regular\", \"Bookman\", \"URW Bookman L\", serif',\n                position: 'relative',\n                marginRight: needsDropZoneSpace ? '156px' : '0.4em',\n                marginLeft: '0',\n                lineHeight: '1.2',\n                verticalAlign: 'top',\n                willChange: 'transform'\n              },\n              children: [word, /*#__PURE__*/_jsxDEV(\"span\", {\n                \"data-dropzone\": \"true\",\n                style: {\n                  position: 'absolute',\n                  display: 'inline-flex',\n                  width: '140px',\n                  height: '140px',\n                  border: isDragging && activeDropZoneIndex === index ? '6px dashed #ccc' : 'none',\n                  borderRadius: '20px',\n                  justifyContent: 'center',\n                  alignItems: 'center',\n                  transition: 'opacity 0.03s linear',\n                  // Ultra-fast transition\n                  opacity: isDropZoneActive ? 1 : 0,\n                  visibility: needsDropZoneSpace ? 'visible' : 'hidden',\n                  pointerEvents: isDragging && activeDropZoneIndex === index ? 'auto' : 'none',\n                  left: '100%',\n                  top: '50%',\n                  marginLeft: '8px',\n                  marginTop: '-70px',\n                  transformOrigin: 'left center',\n                  zIndex: 1000\n                },\n                onDragOver: e => {\n                  e.preventDefault();\n                  if (isDragging && activeDropZoneIndex === index) {\n                    e.currentTarget.style.border = '6px dashed #666';\n                    e.currentTarget.style.transform = 'scale(1.05)';\n                  }\n                },\n                onDragLeave: e => {\n                  e.preventDefault();\n                  if (isDragging && activeDropZoneIndex === index) {\n                    e.currentTarget.style.border = '6px dashed #ccc';\n                    e.currentTarget.style.transform = 'scale(1)';\n                  }\n                },\n                onDrop: e => {\n                  e.preventDefault();\n                  if (feedbackTimeout) {\n                    clearTimeout(feedbackTimeout);\n                  }\n                  setIsDragging(false);\n                  setActiveDropZoneIndex(null);\n\n                  // Get the type from the event\n                  const droppedType = e.dataTransfer.getData('application/punctuation');\n\n                  // Calculate the expected index\n                  const expectedIndex = (currentPhrase === null || currentPhrase === void 0 ? void 0 : currentPhrase.position) === 'end' ? words.length - 1 : currentPhrase === null || currentPhrase === void 0 ? void 0 : currentPhrase.position;\n\n                  // Check if we dropped in the right spot\n                  const isCorrect = droppedType === (currentPhrase === null || currentPhrase === void 0 ? void 0 : currentPhrase.answer) && index === expectedIndex;\n                  console.log('Answer check:', {\n                    droppedType,\n                    expectedType: currentPhrase === null || currentPhrase === void 0 ? void 0 : currentPhrase.answer,\n                    droppedAt: index,\n                    expectedIndex,\n                    isCorrect,\n                    willUpdateScore: isCorrect ? 'correct + 1' : 'incorrect + 1'\n                  });\n\n                  // Handle the drop first\n                  handleDrop(e);\n\n                  // Then set feedback with a tiny delay\n                  setTimeout(() => {\n                    setDroppedIndex(index);\n                    setShowingFeedback(true);\n                    setIsCorrect(isCorrect);\n\n                    // Simple score update:\n                    // If correct (happy face) -> correct + 1\n                    // If incorrect (sad face) -> incorrect + 1\n                    if (isCorrect) {\n                      setScore(prev => ({\n                        ...prev,\n                        correct: prev.correct + 1\n                      }));\n                    } else {\n                      setScore(prev => ({\n                        ...prev,\n                        incorrect: prev.incorrect + 1\n                      }));\n                    }\n\n                    // Clear feedback after 2 seconds\n                    const timeout = setTimeout(() => {\n                      if (isCorrect) {\n                        goToNextPhrase();\n                      } else {\n                        setSelectedMark(null);\n                        setIsCorrect(null);\n                        setShowingFeedback(false);\n                        setDroppedIndex(null);\n                      }\n                    }, 2000);\n                    setFeedbackTimeout(timeout);\n                  }, 0);\n                },\n                children: isDropZoneActive && selectedMark && /*#__PURE__*/_jsxDEV(\"div\", {\n                  style: {\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    width: '100%',\n                    height: '100%'\n                  },\n                  children: /*#__PURE__*/_jsxDEV(PunctuationCharacter, {\n                    type: selectedMark,\n                    onClick: () => {},\n                    isCorrect: isCorrect,\n                    isDraggable: false,\n                    onSelect: () => {}\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 538,\n                    columnNumber: 25\n                  }, this)\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 531,\n                  columnNumber: 23\n                }, this)\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 423,\n                columnNumber: 19\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 409,\n              columnNumber: 17\n            }, this), !needsLineBreak && ' ']\n          }, index, true, {\n            fileName: _jsxFileName,\n            lineNumber: 407,\n            columnNumber: 15\n          }, this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 384,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 344,\n      columnNumber: 7\n    }, this);\n  };\n  const handleGameOverClose = () => {\n    setGameOverOpen(false);\n    navigate('/select');\n  };\n  const formatTime = seconds => {\n    if (seconds === null) return \"0:00\";\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n  };\n  const TimerDisplay = () => /*#__PURE__*/_jsxDEV(\"div\", {\n    className: `timer ${!hasStarted || timeLeft === null ? '' : timeLeft < 10 ? 'timer-warning' : ''}`,\n    children: /*#__PURE__*/_jsxDEV(\"span\", {\n      className: \"timer-text\",\n      children: formatTime(timeLeft)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 573,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 571,\n    columnNumber: 5\n  }, this);\n  React.useEffect(() => {\n    if (settings.timer) {\n      setTimeLeft(settings.timeLimit);\n    }\n  }, [settings.timer, settings.timeLimit]);\n  const TopBar = () => /*#__PURE__*/_jsxDEV(\"header\", {\n    className: \"top-bar\",\n    children: [/*#__PURE__*/_jsxDEV(Button, {\n      onClick: () => navigate('/select'),\n      children: \"DONE\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 587,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      className: \"score-display\",\n      children: [\"CORRECT: \", score.correct, \" INCORRECT: \", score.incorrect]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 590,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 586,\n    columnNumber: 5\n  }, this);\n  React.useEffect(() => {\n    if (!currentPhrase) return;\n\n    // Pre-calculate all possible drop zone positions\n    const testDiv = document.createElement('div');\n    testDiv.style.visibility = 'hidden';\n    testDiv.style.position = 'absolute';\n    testDiv.style.width = '90%';\n    testDiv.style.fontSize = window.innerWidth < 600 ? '80px' : window.innerWidth < 960 ? '100px' : window.innerWidth < 1280 ? '120px' : '140px';\n    testDiv.style.fontFamily = '\"Bookman Old Style Regular\", \"Bookman\", \"URW Bookman L\", serif';\n    document.body.appendChild(testDiv);\n    const words = currentPhrase.text.split(' ');\n    const breaks = [];\n    const spaces = [];\n\n    // Test each word position\n    words.forEach((_, index) => {\n      // Add space for potential drop zone after each word\n      spaces.push(index);\n\n      // Test if this causes a line break\n      testDiv.innerHTML = words.slice(0, index + 1).join(' ');\n      const heightWithoutSpace = testDiv.offsetHeight;\n      testDiv.innerHTML = words.slice(0, index + 1).join(' ') + ' '.repeat(20);\n      const heightWithSpace = testDiv.offsetHeight;\n      if (heightWithSpace > heightWithoutSpace) {\n        breaks.push(index);\n      }\n    });\n\n    // If it's an end position phrase, always add space at the end\n    if (currentPhrase.position === 'end') {\n      spaces.push(words.length - 1);\n    }\n    document.body.removeChild(testDiv);\n    setPhraseLayout({\n      lineBreaks: breaks,\n      dropZoneSpaces: spaces\n    });\n  }, [currentPhrase]);\n  React.useEffect(() => {\n    return () => {\n      if (feedbackTimeout) {\n        clearTimeout(feedbackTimeout);\n      }\n    };\n  }, [feedbackTimeout]);\n\n  // Add this effect to pre-calculate positions when phrase changes\n  React.useEffect(() => {\n    if (!currentPhrase) return;\n\n    // Pre-calculate positions immediately when phrase changes\n    requestAnimationFrame(() => {\n      const wordElements = document.querySelectorAll('[data-word-index]');\n      wordElements.forEach(word => {\n        // Force layout calculation\n        word.getBoundingClientRect();\n      });\n    });\n  }, [currentPhrase]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-screen\",\n    children: [/*#__PURE__*/_jsxDEV(TopBar, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 664,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"main\", {\n      className: \"game-content\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"phrase-container\",\n        children: renderPhrase()\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 667,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 666,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"footer\", {\n      className: \"character-controls\",\n      children: shuffledTypes.map(type => /*#__PURE__*/_jsxDEV(PunctuationCharacter, {\n        type: type,\n        onClick: () => handleCharacterSelect(type),\n        isCorrect: undefined,\n        isDraggable: true,\n        onDragStart: () => setSelectedMark(null),\n        onSelect: handleCharacterSelect\n      }, type, false, {\n        fileName: _jsxFileName,\n        lineNumber: 674,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 672,\n      columnNumber: 7\n    }, this), settings.timer && /*#__PURE__*/_jsxDEV(TimerDisplay, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 686,\n      columnNumber: 26\n    }, this), /*#__PURE__*/_jsxDEV(GameOverDialog, {\n      open: gameOverOpen,\n      onClose: handleGameOverClose,\n      score: score\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 688,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 663,\n    columnNumber: 5\n  }, this);\n};\n_s(GameScreen, \"8y9OezVmEwM52QP8mGtmngetTCU=\", false, function () {\n  return [useNavigate, useGame];\n});\n_c2 = GameScreen;\nexport default GameScreen;\nvar _c, _c2;\n$RefreshReg$(_c, \"GameOverDialog\");\n$RefreshReg$(_c2, \"GameScreen\");","map":{"version":3,"names":["React","useState","useCallback","useNavigate","useGame","PunctuationCharacter","shuffleArray","Button","jsxDEV","_jsxDEV","samplePhrases","period","text","answer","position","exclamation","question","comma","punctuationTypes","GameOverDialog","open","onClose","score","className","children","fileName","_jsxFileName","lineNumber","columnNumber","correct","incorrect","onClick","_c","GameScreen","_s","navigate","punctuationType","settings","currentPhraseIndex","setCurrentPhraseIndex","currentPhrase","setCurrentPhrase","selectedMark","setSelectedMark","isCorrect","setIsCorrect","setScore","hasStarted","setHasStarted","timeLeft","setTimeLeft","gameOverOpen","setGameOverOpen","shuffledTypes","setShuffledTypes","feedback","setFeedback","timerRef","useRef","dragPosition","setDragPosition","closestDropZone","setClosestDropZone","hoveredIndex","setHoveredIndex","isDragging","setIsDragging","showingFeedback","setShowingFeedback","lineBreaks","setLineBreaks","activeDropZoneIndex","setActiveDropZoneIndex","droppedIndex","setDroppedIndex","feedbackTimeout","setFeedbackTimeout","phraseLayout","setPhraseLayout","dropZoneSpaces","droppedType","setDroppedType","phrases","useMemo","Object","values","flat","useEffect","startTimer","timer","timeLimit","current","setInterval","prev","clearInterval","handleFirstInteraction","getFeedbackMessage","type","correctType","handleCharacterSelect","isCorrectMark","setTimeout","goToNextPhrase","nextIndex","length","handleDrop","e","preventDefault","currentTarget","classList","remove","dataTransfer","getData","console","log","handleDragOver","style","backgroundColor","handleDragLeave","handleDragStart","setData","id","findClosestWord","dragPos","wordElements","document","querySelectorAll","closestDistance","Infinity","forEach","element","index","rect","getBoundingClientRect","dropZoneCenter","x","left","width","y","top","height","distance","Math","sqrt","pow","getClosestWordIndex","words","container","querySelector","containerRect","lastWord","lastWordRect","distanceToEnd","abs","right","bottom","i","word","nextWord","nextRect","gap","min","max","renderPhrase","split","textAlign","willChange","transform","backfaceVisibility","onDragEnter","onDragLeave","target","onDragOver","newPos","clientX","clientY","newClosestIndex","onDrop","fontFamily","fontWeight","fontSize","window","innerWidth","lineHeight","display","maxWidth","margin","WebkitFontSmoothing","WebkitTextSizeAdjust","color","map","needsLineBreak","includes","needsDropZoneSpace","isDropZoneActive","Fragment","marginRight","marginLeft","verticalAlign","border","borderRadius","justifyContent","alignItems","transition","opacity","visibility","pointerEvents","marginTop","transformOrigin","zIndex","clearTimeout","expectedIndex","expectedType","droppedAt","willUpdateScore","timeout","isDraggable","onSelect","handleGameOverClose","formatTime","seconds","minutes","floor","remainingSeconds","toString","padStart","TimerDisplay","TopBar","testDiv","createElement","body","appendChild","breaks","spaces","_","push","innerHTML","slice","join","heightWithoutSpace","offsetHeight","repeat","heightWithSpace","removeChild","requestAnimationFrame","undefined","onDragStart","_c2","$RefreshReg$"],"sources":["/Users/benediktlehnert/Documents/GitHub/punx-app-new/src/screens/GameScreen.tsx"],"sourcesContent":["import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { useGame } from '../context/GameContext';\nimport PunctuationCharacter from '../components/PunctuationCharacter';\nimport { shuffleArray } from '../utils/shuffle';\nimport { Button } from '../components/Button';\nimport '../styles/GameScreen.css';\n\ntype Phrase = {\n  text: string;\n  answer: string;\n  position: 'end' | number; // 'end' or index where punctuation should go\n};\n\ntype PhraseCollection = {\n  period: Phrase[];\n  exclamation: Phrase[];\n  question: Phrase[];\n  comma: Phrase[];\n};\n\nconst samplePhrases: PhraseCollection = {\n  period: [\n    { text: \"I love to play in the park\", answer: \"period\", position: 'end' },\n    { text: \"The sun is shining today\", answer: \"period\", position: 'end' },\n  ],\n  exclamation: [\n    { text: \"What a wonderful day\", answer: \"exclamation\", position: 'end' },\n    { text: \"I can’t believe it\", answer: \"exclamation\", position: 'end' },\n  ],\n  question: [\n    { text: \"How are you today\", answer: \"question\", position: 'end' },\n    { text: \"Where did you go\", answer: \"question\", position: 'end' },\n  ],\n  comma: [\n    { text: \"After the movie we went home\", answer: \"comma\", position: 2 }, // After index 2 (after \"movie\")\n    { text: \"Yes I would love to\", answer: \"comma\", position: 0 }, // After index 1 (after \"Yes\")\n  ],\n};\n\ntype PunctuationType = 'period' | 'exclamation' | 'question' | 'comma';\n\nconst punctuationTypes: PunctuationType[] = ['period', 'exclamation', 'question', 'comma'];\n\ninterface FeedbackMessage {\n  text: string;\n  type: 'success' | 'error';\n}\n\ninterface GameOverDialogProps {\n  open: boolean;\n  onClose: () => void;\n  score: { correct: number; incorrect: number };\n}\n\nconst GameOverDialog = ({ open, onClose, score }: GameOverDialogProps) => (\n  <dialog open={open} className=\"game-over-dialog\">\n    <div className=\"dialog-content\">\n      <h2>Time's Up!</h2>\n      <p className=\"score-correct\">Correct Answers: {score.correct}</p>\n      <p className=\"score-incorrect\">Incorrect Answers: {score.incorrect}</p>\n      <p className=\"feedback\">\n        {score.correct > score.incorrect \n          ? \"Great job! You're getting really good at this!\" \n          : \"Keep practicing, you're getting better!\"}\n      </p>\n      <div className=\"dialog-actions\">\n        <Button onClick={onClose}>Play Again</Button>\n      </div>\n    </div>\n  </dialog>\n);\n\nconst GameScreen = () => {\n  const navigate = useNavigate();\n  const { punctuationType, settings } = useGame();\n  const [currentPhraseIndex, setCurrentPhraseIndex] = React.useState(0);\n  const [currentPhrase, setCurrentPhrase] = React.useState<Phrase | null>(null);\n  const [selectedMark, setSelectedMark] = React.useState<PunctuationType | null>(null);\n  const [isCorrect, setIsCorrect] = React.useState<boolean | null>(null);\n  const [score, setScore] = React.useState({ correct: 0, incorrect: 0 });\n  const [hasStarted, setHasStarted] = React.useState(false);\n  const [timeLeft, setTimeLeft] = React.useState<number | null>(null);\n  const [gameOverOpen, setGameOverOpen] = React.useState(false);\n  const [shuffledTypes, setShuffledTypes] = React.useState<PunctuationType[]>(['period', 'exclamation', 'question', 'comma']);\n  const [feedback, setFeedback] = React.useState<FeedbackMessage | null>(null);\n  const timerRef = React.useRef<NodeJS.Timeout | null>(null);\n  const [dragPosition, setDragPosition] = useState<{ x: number; y: number } | null>(null);\n  const [closestDropZone, setClosestDropZone] = useState<number | null>(null);\n  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const [showingFeedback, setShowingFeedback] = useState(false);\n  const [lineBreaks, setLineBreaks] = useState<number[]>([]);\n  const [activeDropZoneIndex, setActiveDropZoneIndex] = useState<number | null>(null);\n  const [droppedIndex, setDroppedIndex] = useState<number | null>(null);\n  const [feedbackTimeout, setFeedbackTimeout] = useState<NodeJS.Timeout | null>(null);\n  const [phraseLayout, setPhraseLayout] = useState<{ \n    lineBreaks: number[],\n    dropZoneSpaces: number[]\n  }>({ lineBreaks: [], dropZoneSpaces: [] });\n  const [droppedType, setDroppedType] = useState<PunctuationType | null>(null);\n\n  const phrases = React.useMemo(() => shuffleArray(Object.values(samplePhrases).flat()), []);\n\n  React.useEffect(() => {\n    setCurrentPhrase(phrases[currentPhraseIndex]);\n  }, [currentPhraseIndex, phrases]);\n\n  const startTimer = React.useCallback(() => {\n    if (!hasStarted && settings.timer) {\n      setHasStarted(true);\n      setTimeLeft(settings.timeLimit);\n    }\n  }, [hasStarted, settings.timer, settings.timeLimit]);\n\n  React.useEffect(() => {\n    if (hasStarted && settings.timer && timeLeft !== null && timeLeft > 0) {\n      timerRef.current = setInterval(() => {\n        setTimeLeft((prev) => {\n          if (prev === null || prev <= 1) {\n            if (timerRef.current) {\n              clearInterval(timerRef.current);\n            }\n            setGameOverOpen(true);\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n\n      return () => {\n        if (timerRef.current) {\n          clearInterval(timerRef.current);\n        }\n      };\n    }\n  }, [hasStarted, settings.timer, timeLeft]);\n\n  React.useEffect(() => {\n    return () => {\n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n      }\n    };\n  }, []);\n\n  const handleFirstInteraction = () => {\n    startTimer();\n  };\n\n  const getFeedbackMessage = (type: string, isCorrect: boolean): FeedbackMessage => {\n    if (isCorrect) {\n      return {\n        text: \"Great job! That's exactly right!\",\n        type: 'success'\n      };\n    }\n\n    const correctType = currentPhrase?.answer;\n    switch (correctType) {\n      case 'period':\n        return {\n          text: \"This sentence needs a period to show it's complete.\",\n          type: 'error'\n        };\n      case 'question':\n        return {\n          text: \"This is a question, so it needs a question mark.\",\n          type: 'error'\n        };\n      case 'exclamation':\n        return {\n          text: \"This sentence shows strong feeling or emotion, so it needs an exclamation mark!\",\n          type: 'error'\n        };\n      case 'comma':\n        return {\n          text: \"A comma is needed here to separate parts of the sentence.\",\n          type: 'error'\n        };\n      default:\n        return {\n          text: \"That's not quite right. Try again!\",\n          type: 'error'\n        };\n    }\n  };\n\n  const handleCharacterSelect = (type: PunctuationType) => {\n    if (!currentPhrase) return;\n\n    // Start timer on first interaction if not started\n    if (!hasStarted) {\n      startTimer();\n    }\n\n    setSelectedMark(type);\n    const isCorrectMark = type === currentPhrase.answer;\n    setIsCorrect(isCorrectMark);\n\n    if (isCorrectMark) {\n      setScore(prev => ({\n        ...prev,\n        correct: prev.correct + 1\n      }));\n    } else {\n      setScore(prev => ({\n        ...prev,\n        incorrect: prev.incorrect + 1\n      }));\n    }\n\n    // Wait for animation then move to next phrase\n    setTimeout(() => {\n      setSelectedMark(null);\n      setIsCorrect(null);\n      goToNextPhrase();\n    }, 1000);\n  };\n\n  const goToNextPhrase = () => {\n    const nextIndex = (currentPhraseIndex + 1) % phrases.length;\n    setCurrentPhraseIndex(nextIndex);\n  };\n\n  const handleDrop = (e: React.DragEvent<HTMLElement>) => {\n    e.preventDefault();\n    e.currentTarget.classList.remove('dragover');\n    const droppedType = e.dataTransfer.getData('application/punctuation') as PunctuationType;\n    \n    console.log('Dropped type:', droppedType); // Add this for debugging\n    \n    if (droppedType) {\n      handleCharacterSelect(droppedType);\n    }\n  };\n\n  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {\n    e.preventDefault(); // This is crucial for enabling drop\n    e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';\n  };\n\n  const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.currentTarget.style.backgroundColor = 'transparent';\n  };\n\n  const handleDragStart = (e: React.DragEvent) => {\n    startTimer();\n    e.dataTransfer.setData('text/plain', e.currentTarget.id);\n  };\n\n  const findClosestWord = useCallback((dragPos: { x: number; y: number } | null) => {\n    if (!dragPos) return null;\n\n    // Get all word elements\n    const wordElements = document.querySelectorAll('[data-dropzone=\"true\"]');\n    let closestDropZone = null;\n    let closestDistance = Infinity;\n\n    wordElements.forEach((element, index) => {\n      const rect = element.getBoundingClientRect();\n      const dropZoneCenter = {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2\n      };\n\n      const distance = Math.sqrt(\n        Math.pow(dragPos.x - dropZoneCenter.x, 2) + \n        Math.pow(dragPos.y - dropZoneCenter.y, 2)\n      );\n\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestDropZone = index;\n      }\n    });\n\n    // Only return the closest drop zone if it's within a reasonable distance (e.g., 200px)\n    return closestDistance < 200 ? closestDropZone : null;\n  }, []);\n\n  const getClosestWordIndex = (dragPos: { x: number; y: number } | null, words: NodeListOf<Element>) => {\n    if (!dragPos) return null;\n    \n    // Get the phrase container bounds\n    const container = document.querySelector('.phrase-container');\n    if (!container) return null;\n    const containerRect = container.getBoundingClientRect();\n    \n    // Check if we're near the end of the phrase\n    const lastWord = words[words.length - 1];\n    const lastWordRect = lastWord.getBoundingClientRect();\n    const distanceToEnd = Math.abs(dragPos.x - (lastWordRect.right + 78));\n    \n    // If we're near the end of the last line and it's an end position phrase\n    if (currentPhrase?.position === 'end' && \n        dragPos.y > lastWordRect.top - 50 && \n        dragPos.y < lastWordRect.bottom + 50 &&\n        dragPos.x > lastWordRect.right) {\n      return words.length - 1;\n    }\n    \n    // Check each word position\n    for (let i = 0; i < words.length; i++) {\n      const word = words[i];\n      const rect = word.getBoundingClientRect();\n      const nextWord = words[i + 1];\n      const nextRect = nextWord?.getBoundingClientRect();\n      \n      // If this is the last word, check if we're after it\n      if (!nextWord && dragPos.x > rect.right) {\n        return i;\n      }\n      \n      // Check if we're between this word and the next\n      if (nextRect) {\n        const gap = {\n          left: rect.right,\n          right: nextRect.left,\n          top: Math.min(rect.top, nextRect.top),\n          bottom: Math.max(rect.bottom, nextRect.bottom)\n        };\n        \n        // Check if we're in the gap between words\n        if (dragPos.x >= gap.left && \n            dragPos.x <= gap.right && \n            dragPos.y >= gap.top - 50 && \n            dragPos.y <= gap.bottom + 50) {\n          return i;\n        }\n      }\n    }\n    \n    return null;\n  };\n\n  const renderPhrase = () => {\n    if (!currentPhrase) return null;\n\n    const words = currentPhrase.text.split(' ');\n    \n    return (\n      <div \n        className=\"phrase-container\"\n        style={{ \n          width: '100%',\n          textAlign: 'center',\n          willChange: 'transform',\n          transform: 'translateZ(0)',\n          backfaceVisibility: 'hidden'\n        }}\n        onDragEnter={() => setIsDragging(true)}\n        onDragLeave={(e) => {\n          if (e.currentTarget === e.target) {\n            setIsDragging(false);\n            setDragPosition(null);\n            setActiveDropZoneIndex(null);\n          }\n        }}\n        onDragOver={(e) => {\n          e.preventDefault();\n          const newPos = { x: e.clientX, y: e.clientY };\n          \n          // Update position immediately with minimal threshold\n          if (!dragPosition || \n              Math.abs(newPos.x - dragPosition.x) > 2 || // Minimal threshold\n              Math.abs(newPos.y - dragPosition.y) > 2) {\n            setDragPosition(newPos);\n            \n            const wordElements = document.querySelectorAll('[data-word-index]');\n            const newClosestIndex = getClosestWordIndex(newPos, wordElements);\n            \n            if (newClosestIndex !== activeDropZoneIndex) {\n              setActiveDropZoneIndex(newClosestIndex);\n            }\n          }\n        }}\n        onDrop={() => {\n          setIsDragging(false);\n          setDragPosition(null);\n        }}\n      >\n        <div \n          style={{\n            fontFamily: '\"Bookman Old Style Regular\", \"Bookman\", \"URW Bookman L\", serif',\n            fontWeight: 'normal',\n            fontSize: window.innerWidth < 600 ? '80px' : \n                     window.innerWidth < 960 ? '100px' : \n                     window.innerWidth < 1280 ? '120px' : '140px',\n            lineHeight: '1.1',\n            display: 'inline-block',\n            textAlign: 'left',\n            maxWidth: '90%',\n            margin: '0 auto',\n            WebkitFontSmoothing: 'antialiased',\n            WebkitTextSizeAdjust: '100%',\n            color: '#000000'\n          }}\n        >\n          {words.map((word, index) => {\n            const needsLineBreak = phraseLayout.lineBreaks.includes(index);\n            const needsDropZoneSpace = phraseLayout.dropZoneSpaces.includes(index);\n            const isDropZoneActive = (isDragging && activeDropZoneIndex === index) || droppedIndex === index;\n\n            return (\n              <React.Fragment key={index}>\n                {needsLineBreak && <br />}\n                <span \n                  data-word-index={index}\n                  style={{ \n                    display: 'inline-block',\n                    fontFamily: '\"Bookman Old Style Regular\", \"Bookman\", \"URW Bookman L\", serif',\n                    position: 'relative',\n                    marginRight: needsDropZoneSpace ? '156px' : '0.4em',\n                    marginLeft: '0',\n                    lineHeight: '1.2',\n                    verticalAlign: 'top',\n                    willChange: 'transform'\n                  }}\n                >\n                  {word}\n                  <span\n                    data-dropzone=\"true\"\n                    style={{\n                      position: 'absolute',\n                      display: 'inline-flex',\n                      width: '140px',\n                      height: '140px',\n                      border: isDragging && activeDropZoneIndex === index ? '6px dashed #ccc' : 'none',\n                      borderRadius: '20px',\n                      justifyContent: 'center',\n                      alignItems: 'center',\n                      transition: 'opacity 0.03s linear', // Ultra-fast transition\n                      opacity: isDropZoneActive ? 1 : 0,\n                      visibility: needsDropZoneSpace ? 'visible' : 'hidden',\n                      pointerEvents: (isDragging && activeDropZoneIndex === index) ? 'auto' : 'none',\n                      left: '100%',\n                      top: '50%',\n                      marginLeft: '8px',\n                      marginTop: '-70px',\n                      transformOrigin: 'left center',\n                      zIndex: 1000\n                    }}\n                    onDragOver={(e) => {\n                      e.preventDefault();\n                      if (isDragging && activeDropZoneIndex === index) {\n                        e.currentTarget.style.border = '6px dashed #666';\n                        e.currentTarget.style.transform = 'scale(1.05)';\n                      }\n                    }}\n                    onDragLeave={(e) => {\n                      e.preventDefault();\n                      if (isDragging && activeDropZoneIndex === index) {\n                        e.currentTarget.style.border = '6px dashed #ccc';\n                        e.currentTarget.style.transform = 'scale(1)';\n                      }\n                    }}\n                    onDrop={(e) => {\n                      e.preventDefault();\n                      \n                      if (feedbackTimeout) {\n                        clearTimeout(feedbackTimeout);\n                      }\n                      \n                      setIsDragging(false);\n                      setActiveDropZoneIndex(null);\n                      \n                      // Get the type from the event\n                      const droppedType = e.dataTransfer.getData('application/punctuation');\n                      \n                      // Calculate the expected index\n                      const expectedIndex = currentPhrase?.position === 'end' \n                        ? words.length - 1 \n                        : currentPhrase?.position;\n                      \n                      // Check if we dropped in the right spot\n                      const isCorrect = droppedType === currentPhrase?.answer && \n                                       index === expectedIndex;\n                      \n                      console.log('Answer check:', {\n                        droppedType,\n                        expectedType: currentPhrase?.answer,\n                        droppedAt: index,\n                        expectedIndex,\n                        isCorrect,\n                        willUpdateScore: isCorrect ? 'correct + 1' : 'incorrect + 1'\n                      });\n                      \n                      // Handle the drop first\n                      handleDrop(e);\n                      \n                      // Then set feedback with a tiny delay\n                      setTimeout(() => {\n                        setDroppedIndex(index);\n                        setShowingFeedback(true);\n                        setIsCorrect(isCorrect);\n                        \n                        // Simple score update:\n                        // If correct (happy face) -> correct + 1\n                        // If incorrect (sad face) -> incorrect + 1\n                        if (isCorrect) {\n                          setScore(prev => ({\n                            ...prev,\n                            correct: prev.correct + 1\n                          }));\n                        } else {\n                          setScore(prev => ({\n                            ...prev,\n                            incorrect: prev.incorrect + 1\n                          }));\n                        }\n                        \n                        // Clear feedback after 2 seconds\n                        const timeout = setTimeout(() => {\n                          if (isCorrect) {\n                            goToNextPhrase();\n                          } else {\n                            setSelectedMark(null);\n                            setIsCorrect(null);\n                            setShowingFeedback(false);\n                            setDroppedIndex(null);\n                          }\n                        }, 2000);\n                        \n                        setFeedbackTimeout(timeout);\n                      }, 0);\n                    }}\n                  >\n                    {isDropZoneActive && selectedMark && (\n                      <div style={{\n                        display: 'flex',\n                        justifyContent: 'center',\n                        alignItems: 'center',\n                        width: '100%',\n                        height: '100%',\n                      }}>\n                        <PunctuationCharacter\n                          type={selectedMark}\n                          onClick={() => {}}\n                          isCorrect={isCorrect}\n                          isDraggable={false}\n                          onSelect={() => {}}\n                        />\n                      </div>\n                    )}\n                  </span>\n                </span>\n                {!needsLineBreak && ' '}\n              </React.Fragment>\n            );\n          })}\n        </div>\n      </div>\n    );\n  };\n\n  const handleGameOverClose = () => {\n    setGameOverOpen(false);\n    navigate('/select');\n  };\n\n  const formatTime = (seconds: number | null): string => {\n    if (seconds === null) return \"0:00\";\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n  };\n\n  const TimerDisplay = () => (\n    <div className={`timer ${(!hasStarted || timeLeft === null) ? '' : \n      timeLeft < 10 ? 'timer-warning' : ''}`}>\n      <span className=\"timer-text\">\n        {formatTime(timeLeft)}\n      </span>\n    </div>\n  );\n\n  React.useEffect(() => {\n    if (settings.timer) {\n      setTimeLeft(settings.timeLimit);\n    }\n  }, [settings.timer, settings.timeLimit]);\n\n  const TopBar = () => (\n    <header className=\"top-bar\">\n      <Button onClick={() => navigate('/select')}>\n        DONE\n      </Button>\n      <p className=\"score-display\">\n        CORRECT: {score.correct} INCORRECT: {score.incorrect}\n      </p>\n    </header>\n  );\n\n  React.useEffect(() => {\n    if (!currentPhrase) return;\n\n    // Pre-calculate all possible drop zone positions\n    const testDiv = document.createElement('div');\n    testDiv.style.visibility = 'hidden';\n    testDiv.style.position = 'absolute';\n    testDiv.style.width = '90%';\n    testDiv.style.fontSize = window.innerWidth < 600 ? '80px' : \n                            window.innerWidth < 960 ? '100px' : \n                            window.innerWidth < 1280 ? '120px' : '140px';\n    testDiv.style.fontFamily = '\"Bookman Old Style Regular\", \"Bookman\", \"URW Bookman L\", serif';\n    document.body.appendChild(testDiv);\n\n    const words = currentPhrase.text.split(' ');\n    const breaks: number[] = [];\n    const spaces: number[] = [];\n\n    // Test each word position\n    words.forEach((_, index) => {\n      // Add space for potential drop zone after each word\n      spaces.push(index);\n      \n      // Test if this causes a line break\n      testDiv.innerHTML = words.slice(0, index + 1).join(' ');\n      const heightWithoutSpace = testDiv.offsetHeight;\n      \n      testDiv.innerHTML = words.slice(0, index + 1).join(' ') + ' '.repeat(20);\n      const heightWithSpace = testDiv.offsetHeight;\n      \n      if (heightWithSpace > heightWithoutSpace) {\n        breaks.push(index);\n      }\n    });\n\n    // If it's an end position phrase, always add space at the end\n    if (currentPhrase.position === 'end') {\n      spaces.push(words.length - 1);\n    }\n\n    document.body.removeChild(testDiv);\n    setPhraseLayout({ lineBreaks: breaks, dropZoneSpaces: spaces });\n  }, [currentPhrase]);\n\n  React.useEffect(() => {\n    return () => {\n      if (feedbackTimeout) {\n        clearTimeout(feedbackTimeout);\n      }\n    };\n  }, [feedbackTimeout]);\n\n  // Add this effect to pre-calculate positions when phrase changes\n  React.useEffect(() => {\n    if (!currentPhrase) return;\n\n    // Pre-calculate positions immediately when phrase changes\n    requestAnimationFrame(() => {\n      const wordElements = document.querySelectorAll('[data-word-index]');\n      wordElements.forEach((word) => {\n        // Force layout calculation\n        word.getBoundingClientRect();\n      });\n    });\n  }, [currentPhrase]);\n\n  return (\n    <div className=\"game-screen\">\n      <TopBar />\n      \n      <main className=\"game-content\">\n        <div className=\"phrase-container\">\n          {renderPhrase()}\n        </div>\n      </main>\n\n      <footer className=\"character-controls\">\n        {shuffledTypes.map((type) => (\n          <PunctuationCharacter\n            key={type}\n            type={type}\n            onClick={() => handleCharacterSelect(type)}\n            isCorrect={undefined}\n            isDraggable={true}\n            onDragStart={() => setSelectedMark(null)}\n            onSelect={handleCharacterSelect}\n          />\n        ))}\n      </footer>\n\n      {settings.timer && <TimerDisplay />}\n      \n      <GameOverDialog \n        open={gameOverOpen} \n        onClose={handleGameOverClose}\n        score={score}\n      />\n    </div>\n  );\n};\n\nexport default GameScreen;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}